# 3. 데이터베이스 모델링

## MariaDB 기본 개념 및 테이블 설계

### 1. MariaDB란?

MariaDB는 MySQL에서 분기된 오픈소스 관계형 데이터베이스(RDBMS)다.
 MySQL과의 호환성을 유지하며, 성능 및 확장성 면에서 지속적인 개선이 이루어지고 있다.

------

### 2. 주요 개념 요약

| 용어                    | 설명                                                   |
| ----------------------- | ------------------------------------------------------ |
| 데이터베이스 (Database) | 테이블들의 논리적 집합                                 |
| 테이블 (Table)          | 행(Row)과 열(Column)로 구성된 실제 데이터 저장 구조    |
| 열(Column)              | 데이터의 속성(attribute), 필드(field)라고도 함         |
| 행(Row)                 | 개별 데이터 레코드                                     |
| 기본 키(Primary Key)    | 각 레코드를 고유하게 식별하는 열                       |
| 외래 키(Foreign Key)    | 다른 테이블의 기본 키를 참조하는 열                    |
| 인덱스(Index)           | 검색 성능을 높이기 위한 데이터 구조                    |
| 제약조건(Constraint)    | 데이터 무결성을 보장하기 위한 규칙 (PK, FK, UNIQUE 등) |

------

### 3. 데이터 형식 요약

| 데이터 타입                     | 설명                                        |
| ------------------------------- | ------------------------------------------- |
| `INT`, `BIGINT`                 | 정수형                                      |
| `VARCHAR(n)`                    | 가변 길이 문자열 (최대 n 바이트)            |
| `TEXT`                          | 긴 문자열                                   |
| `DATE`, `DATETIME`, `TIMESTAMP` | 날짜/시간                                   |
| `BOOLEAN`                       | 논리값 (실제로는 TINYINT)                   |
| `BLOB`                          | 바이너리 대용량 객체 (파일 등 저장 시 사용) |

------

### 4. 테이블 설계 기본 원칙

1. **정규화(Normalization)**
   - 중복 최소화, 무결성 보장
   - 1NF(원자성), 2NF(부분 종속 제거), 3NF(이행 종속 제거) 적용
2. **식별자 설정**
   - 각 테이블에는 `PRIMARY KEY`를 반드시 정의
   - AUTO_INCREMENT 또는 UUID 사용 가능
3. **관계 명확화**
   - `1:N` 관계 → 외래 키로 모델링
   - `N:M` 관계 → 조인 테이블 중간에 생성
4. **시간 정보 포함**
   - `created_at`, `updated_at` 필드 포함 권장 (`DATETIME`, `TIMESTAMP`)
5. **논리 삭제 필드(optional)**
   - `deleted`, `is_active`, `deleted_at` 등 사용 가능

------

### 5. 게시판 도메인 설계 예시

아래는 간단한 게시판 시스템을 위한 테이블 설계 예시다.

------

#### 5.1 User 테이블

```
CREATE TABLE users (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  email VARCHAR(100) NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

------

#### 5.2 Post 테이블

```
CREATE TABLE posts (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  title VARCHAR(200) NOT NULL,
  content TEXT NOT NULL,
  view_count INT DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

#### 5.3 Comment 테이블

```
CREATE TABLE comments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  content TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

#### 5.4 File Attachment 테이블

```
CREATE TABLE attachments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size BIGINT NOT NULL,
  uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id)
);
```

------

### 6. 인덱스 설계

| 인덱스 대상        | 설명                   |
| ------------------ | ---------------------- |
| `users.username`   | 로그인, 검색 속도 향상 |
| `posts.user_id`    | JOIN 성능 향상         |
| `comments.post_id` | 댓글 조회 속도 향상    |
| `created_at`       | 최근 순 정렬 시 유리   |

인덱스 생성 예:

```
CREATE INDEX idx_post_user ON posts(user_id);
CREATE INDEX idx_comment_post ON comments(post_id);
```

------

### 7. ERD 구조 요약

```
[users] 1 ── N [posts] 1 ── N [comments]
                       └── N [attachments]
```

- 1명의 사용자 → 여러 게시글 작성 가능
- 1개의 게시글 → 여러 댓글, 여러 첨부파일 가능

------

### 8. 설계 시 주의할 점

- `TEXT`, `BLOB` 필드는 가급적 별도 테이블 분리 고려 (성능)
- `ON DELETE CASCADE` 사용 여부는 필요에 따라 선택
- `NOT NULL`, `DEFAULT`, `UNIQUE` 등 제약조건 명시 필수
- DB 설계는 애플리케이션 요구사항과 무관하게 **독립적이고 정규화된 상태**로 유지하는 것이 원칙

## ERD 설계 도구 사용 (DB Designer, Draw.io 등)

### 1. ERD란?

ERD(Entity-Relationship Diagram)는 데이터베이스의 테이블과 그 관계(relationship)를 시각적으로 표현한 다이어그램이다.

#### 주요 구성 요소

| 요소             | 설명                             |
| ---------------- | -------------------------------- |
| Entity (엔티티)  | 데이터베이스의 테이블에 해당     |
| Attribute (속성) | 테이블의 컬럼                    |
| Relationship     | 엔티티 간의 연결 (1:1, 1:N, N:M) |
| Primary Key      | 각 엔티티의 고유 식별자          |
| Foreign Key      | 관계를 연결하는 참조 키          |

------

### 2. ERD 설계의 목적

- 테이블 구조 시각화
- 비개발자와의 명세 공유
- DB 정규화 검토
- 프로젝트 초기 스키마 정의
- DDL 자동 생성 및 문서화

------

### 3. 주요 ERD 도구 비교

| 도구                            | 특징                  | 플랫폼      | 장점                               | 단점                    |
| ------------------------------- | --------------------- | ----------- | ---------------------------------- | ----------------------- |
| **DB Designer (dbdesigner.io)** | ERD 전용 웹 기반 도구 | 웹          | 직관적 UI, DDL 생성 지원           | 제한된 무료 플랜        |
| **Draw.io / diagrams.net**      | 범용 다이어그램 도구  | 웹/데스크탑 | 자유도 높음, 로컬 저장 가능        | DDL 생성 불가           |
| **DBeaver**                     | 통합 DB 관리 도구     | 데스크탑    | DB 연동, 자동 ERD 생성             | 복잡한 UI               |
| **MySQL Workbench**             | MySQL/MariaDB 전용    | 데스크탑    | 리버스 엔지니어링, 모델 → DDL 생성 | 무겁고 학습 난이도 있음 |
| **dbdiagram.io**                | 문법 기반 ERD 도구    | 웹          | 버전 관리, 코드 기반 ERD           | 다이어그램 한계 있음    |

------

### 4. DB Designer (https://dbdesigner.io)

#### 4.1 사용 절차

1. 사이트 접속 → 무료 계정 생성
2. 새 프로젝트 생성
3. Table 생성 후 필드 추가 (PK/FK/UNIQUE 등 속성 지정)
4. 테이블 간 관계(Relationship) 정의 (1:1, 1:N, N:M)
5. `Export > MySQL` 메뉴로 DDL 추출 가능

#### 4.2 장점

- 직관적인 UI
- 팀원과 공유 가능
- ERD → DDL 자동 생성
- 컬럼 속성, 인덱스, 제약조건 설정 가능

------

### 5. Draw.io / diagrams.net (https://draw.io)

#### 5.1 사용 절차

1. https://draw.io 접속
2. 다이어그램 종류: `Entity Relation` 선택
3. 사각형으로 테이블 표현 → 안에 필드 삽입
4. 선(Line)으로 관계 표현 (1:N, N:M 직접 작성)
5. Google Drive, OneDrive, 로컬 저장 지원

#### 5.2 장점

- 자유도 높음
- 오프라인 및 클라우드 저장 지원
- 다양한 다이어그램 통합 가능 (UML, 플로우차트 등)

#### 5.3 단점

- 관계형 제약 조건(FK, 제약 등) 자동 적용 불가
- DDL 생성 불가능 (수동 추출 필요)

------

### 6. dbdiagram.io (https://dbdiagram.io)

#### 6.1 문법 예시

```
Table users {
  id int [pk]
  username varchar
  password varchar
}

Table posts {
  id int [pk]
  user_id int [ref: > users.id]
  title varchar
  content text
}
```

- 간결한 텍스트 기반 설계
- GitHub 연동, 버전 관리 기능 탑재
- ERD → PostgreSQL, MySQL, SQLite, MS SQL 변환 가능

------

### 7. DBeaver / MySQL Workbench

- 실제 DB와 연동된 상태에서 **리버스 엔지니어링**으로 ERD 생성 가능
- DB 변경 시 즉시 ERD 갱신 가능
- DDL 자동 생성 및 스키마 내보내기 기능 존재
- 반면 도식화 수준이 정제되어 있진 않음 (도식 조작이 제한적)

------

### 8. 설계 전략 요약

| 설계 원칙                      | 내용                                        |
| ------------------------------ | ------------------------------------------- |
| 테이블은 명사, 단수형으로 명명 | ex: `user`, `post`, `comment`               |
| 관계는 외래 키로 명시          | 1:N 관계는 종속 테이블에 FK                 |
| 시간 정보 포함                 | `created_at`, `updated_at`, `deleted_at` 등 |
| 제약조건 표현                  | PK, FK, NOT NULL, UNIQUE 명시               |
| 색상 또는 그룹으로 도메인 구분 | 관리, 게시글, 파일 등 논리적 묶음 구분      |

------

### 9. 추천 흐름

1. Draw.io로 아이디어 스케치
2. DB Designer 또는 dbdiagram.io로 정식 ERD 작성
3. 팀원과 공유 및 피드백
4. DDL 생성 → MariaDB에 적용
5. IntelliJ + JPA Entity 자동 생성 매핑

## 게시판 테이블 설계

### 1. 설계 목표

- 사용자 인증 기반의 게시글 작성
- 게시글 상세 조회, 수정, 삭제 기능
- 댓글 기능 (작성자 정보 포함)
- 파일 첨부 기능 (여러 파일 업로드 가능)
- 좋아요/추천 기능 (중복 불가)
- 시간 및 삭제 여부 기록

------

### 2. 전체 테이블 목록

| 테이블        | 설명                |
| ------------- | ------------------- |
| `users`       | 사용자 정보         |
| `posts`       | 게시글 정보         |
| `comments`    | 댓글 정보           |
| `attachments` | 첨부파일 메타데이터 |
| `likes`       | 게시글 좋아요 처리  |

------

## 3. users 테이블

```
CREATE TABLE users (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  email VARCHAR(100) NOT NULL UNIQUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

------

### 4. posts 테이블

```
CREATE TABLE posts (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  title VARCHAR(200) NOT NULL,
  content TEXT NOT NULL,
  view_count INT DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  is_deleted BOOLEAN DEFAULT FALSE,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 5. comments 테이블

```
CREATE TABLE comments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  content TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  is_deleted BOOLEAN DEFAULT FALSE,
  FOREIGN KEY (post_id) REFERENCES posts(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 6. attachments 테이블

```
CREATE TABLE attachments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  file_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size BIGINT NOT NULL,
  uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id)
);
```

------

### 7. likes 테이블

```
CREATE TABLE likes (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  liked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (post_id, user_id),
  FOREIGN KEY (post_id) REFERENCES posts(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 8. 테이블 관계 요약 (ERD 개요)

```
users     1 ─── N  posts
users     1 ─── N  comments
users     1 ─── N  likes

posts     1 ─── N  comments
posts     1 ─── N  attachments
posts     1 ─── N  likes
```

------

### 9. 설계 특징 요약

| 요소             | 설계 방식                                               |
| ---------------- | ------------------------------------------------------- |
| 작성자 식별      | `user_id` FK로 연결                                     |
| 삭제 여부        | `is_deleted` (논리 삭제) 필드 사용                      |
| 정렬             | `created_at DESC` 기준 정렬 예상                        |
| 좋아요 중복 방지 | `UNIQUE(post_id, user_id)` 제약                         |
| 첨부파일 저장    | 파일 메타데이터만 DB 저장 (실제 파일은 디스크/스토리지) |

------

### 10. 확장 고려 사항

- 태그 시스템 도입 시 `post_tags` 중간 테이블 필요
- 게시글 신고 기능 추가 시 `reports` 테이블 도입 가능
- 사용자 역할(Role), 권한 관리 필요 시 `roles`, `user_roles` 테이블 설계 필요
- 게시글 타입, 카테고리 분류 시 ENUM 또는 별도 `categories` 테이블 도입

------

### 11. 전체 생성 순서

```
CREATE TABLE users (...);
CREATE TABLE posts (...);
CREATE TABLE comments (...);
CREATE TABLE attachments (...);
CREATE TABLE likes (...);
```

FK 제약 조건 상 반드시 **users → posts → comments → attachments/likes** 순으로 생성해야 한다.

- ## 게시글 (Post)

  ### 1. 개요

  `posts` 테이블은 게시판 시스템의 핵심으로, 사용자가 작성한 글의 **제목, 본문, 작성자, 작성시간, 수정시간, 조회수 등 주요 정보를 저장**하는 구조다.
   다음과 같은 기능과 연동된다:

  - 사용자 계정과의 연관 (작성자)
  - 댓글, 첨부파일, 좋아요와의 관계
  - 목록 조회, 상세보기, 검색, 정렬 기능

  ------

  ### 2. 기본 설계 원칙

  | 설계 항목   | 원칙                                         |
  | ----------- | -------------------------------------------- |
  | 식별자      | 기본키 `id` 사용 (BIGINT, AUTO_INCREMENT)    |
  | 사용자 참조 | `user_id` (FK → `users.id`)                  |
  | 시간 정보   | `created_at`, `updated_at`                   |
  | 조회수      | `view_count` 컬럼으로 관리                   |
  | 삭제 처리   | 물리 삭제 대신 `is_deleted` (논리 삭제) 사용 |
  | 수정 추적   | `ON UPDATE CURRENT_TIMESTAMP` 활용           |

  ------

  ### 3. 테이블 정의 (DDL 예시)

  ```
  CREATE TABLE posts (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    view_count INT DEFAULT 0,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
  );
  ```

  ------

  ### 4. 필드 설명

  | 필드명       | 타입         | 설명                         |
  | ------------ | ------------ | ---------------------------- |
  | `id`         | BIGINT       | 게시글 식별자 (PK)           |
  | `user_id`    | BIGINT       | 작성자 ID (users.id 참조)    |
  | `title`      | VARCHAR(200) | 게시글 제목                  |
  | `content`    | TEXT         | 게시글 본문                  |
  | `view_count` | INT          | 조회수                       |
  | `is_deleted` | BOOLEAN      | 삭제 여부 (논리 삭제 플래그) |
  | `created_at` | DATETIME     | 작성 시각                    |
  | `updated_at` | DATETIME     | 최종 수정 시각               |

  ------

  ### 5. 인덱스 전략

  | 대상 컬럼          | 목적                 |
  | ------------------ | -------------------- |
  | `user_id`          | 사용자별 게시글 조회 |
  | `created_at`       | 최신순 정렬          |
  | `title` (Fulltext) | 검색 기능 구현 시    |

  인덱스 생성 예시:

  ```
  CREATE INDEX idx_posts_user_id ON posts(user_id);
  CREATE INDEX idx_posts_created_at ON posts(created_at);
  ```

  ------

  ### 6. 관계 요약

  | 관계 대상     | 관계 유형 | 설명                               |
  | ------------- | --------- | ---------------------------------- |
  | `users`       | N:1       | 게시글은 하나의 사용자에게 속함    |
  | `comments`    | 1:N       | 게시글 하나에 여러 댓글 존재       |
  | `attachments` | 1:N       | 게시글 하나에 여러 첨부파일 가능   |
  | `likes`       | 1:N       | 게시글에 여러 사용자가 좋아요 가능 |

  ------

  ### 7. 조회수 처리 전략

  조회수(`view_count`)는 다음 방식 중 하나로 증가 처리할 수 있다:

  - 단순 SQL 증가:

    ```
    UPDATE posts SET view_count = view_count + 1 WHERE id = ?;
    ```

  - 비동기 처리:

    - Redis 등으로 임시 저장 후 일정 주기마다 DB 반영

  ------

  ### 8. 논리 삭제 처리

  게시글을 삭제하지 않고 `is_deleted = TRUE`로 표시하고, 실제 조회 시 조건을 걸어 제외한다.

  ```
  SELECT * FROM posts WHERE is_deleted = FALSE;
  ```

  ------

  ### 9. 확장 고려 사항

  | 기능             | 설계 방법                                                    |
  | ---------------- | ------------------------------------------------------------ |
  | 게시글 상태 구분 | ENUM(`draft`, `published`, `archived`) 또는 상태 코드 필드 추가 |
  | 공개 범위        | `is_public`, `access_level` 필드                             |
  | 비밀번호 보호글  | `password` 필드 (NULL 허용)                                  |
  | 게시판 구분      | `board_id` FK 추가 (board 테이블 존재 시)                    |

  ------

  ### 10. 요약

  - `posts`는 게시판 시스템의 중심 테이블이며, 사용자와 강한 연관을 가짐
  - 시간 정보, 삭제 플래그, 조회수 등은 기본 요소로 구성
  - 설계 시 확장 가능성과 성능(인덱스)을 함께 고려해야 함
  - 댓글, 첨부파일, 좋아요 기능과의 관계가 핵심

- ## 사용자 (User)

  ### 1. 개요

  `users` 테이블은 게시판 시스템의 사용자 정보를 저장하며, **게시글 작성, 댓글 작성, 로그인, 권한 관리 등의 핵심 기반**이 되는 테이블이다.
   이 테이블은 외부 노출이 되지 않는 민감 정보를 포함하기 때문에 **보안과 정합성**을 최우선으로 고려해 설계한다.

  ------

  ### 2. 기본 설계 원칙

  | 항목        | 설계 기준                                        |
  | ----------- | ------------------------------------------------ |
  | 고유 식별자 | `id` (PK, BIGINT) 사용, AUTO_INCREMENT 적용      |
  | 로그인 계정 | `username`과 `email`을 고유하게 설정 (UNIQUE)    |
  | 인증 정보   | 비밀번호는 해시 저장 (ex: BCrypt, SHA256)        |
  | 시간 정보   | 생성/수정 시간 필드 포함                         |
  | 활성화 여부 | `is_active`, `is_blocked` 등 상태 필드 옵션      |
  | 논리 삭제   | 기본적으로 미사용, 필요한 경우 `deleted_at` 추가 |

  ------

  ### 3. 테이블 정의 (DDL 예시)

  ```
  CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    nickname VARCHAR(50),
    role VARCHAR(20) DEFAULT 'USER',
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  );
  ```

  ------

  ### 4. 필드 설명

  | 필드명       | 타입         | 설명                              |
  | ------------ | ------------ | --------------------------------- |
  | `id`         | BIGINT       | 사용자 고유 ID (기본키)           |
  | `username`   | VARCHAR(50)  | 로그인용 사용자명, 중복 불가      |
  | `password`   | VARCHAR(255) | 비밀번호 해시값                   |
  | `email`      | VARCHAR(100) | 이메일 주소, 중복 불가            |
  | `nickname`   | VARCHAR(50)  | 사용자 닉네임 (선택적)            |
  | `role`       | VARCHAR(20)  | 사용자 권한 (예: `USER`, `ADMIN`) |
  | `is_active`  | BOOLEAN      | 계정 활성 여부                    |
  | `created_at` | DATETIME     | 계정 생성 시각                    |
  | `updated_at` | DATETIME     | 마지막 수정 시각                  |

  ------

  ### 5. 인덱스 전략

  | 대상 컬럼   | 설명                  |
  | ----------- | --------------------- |
  | `username`  | 로그인 ID 검색 최적화 |
  | `email`     | 계정 복구, 인증용     |
  | `role`      | 권한 기반 접근 제어   |
  | `is_active` | 정지/탈퇴 여부 확인   |

  > 인덱스 예시:

  ```
  CREATE INDEX idx_users_username ON users(username);
  CREATE INDEX idx_users_email ON users(email);
  ```

  ------

  ### 6. 비밀번호 보안 저장

  - 반드시 **해시 알고리즘**으로 암호화하여 저장 (e.g. BCrypt)
  - 평문 저장 절대 금지
  - Spring Security 사용 시 `PasswordEncoder` 설정으로 자동 처리

  ```
  PasswordEncoder encoder = new BCryptPasswordEncoder();
  String hashed = encoder.encode("user_password");
  ```

  ------

  ### 7. 권한 및 역할 관리 (Role-Based Access Control)

  | role 값 | 설명                                |
  | ------- | ----------------------------------- |
  | `USER`  | 일반 사용자                         |
  | `ADMIN` | 관리자 (모든 게시글 삭제/관리 가능) |

  선택적으로 `roles` 테이블을 따로 분리하고 `user_roles` 중간 테이블을 둘 수도 있다 (N:M 구조 확장 시).

  ------

  ### 8. 확장 고려 사항

  | 항목              | 구현 방식                                     |
  | ----------------- | --------------------------------------------- |
  | OAuth 사용자 연동 | `provider`, `provider_id` 필드 추가           |
  | 탈퇴 처리         | `deleted_at` 또는 `is_deleted` 필드 추가      |
  | 접속 로그 관리    | 별도 `login_logs` 테이블 사용                 |
  | 사용자 프로필     | 프로필 이미지 URL 필드 (`profile_image`) 추가 |

  ------

  ### 9. 외래 키 관계 요약

  | 대상 테이블 | 관계 | 설명            |
  | ----------- | ---- | --------------- |
  | `posts`     | 1:N  | 작성자 → 게시글 |
  | `comments`  | 1:N  | 작성자 → 댓글   |
  | `likes`     | 1:N  | 사용자 → 좋아요 |

  ------

  ### 10. 요약

  - `users` 테이블은 인증 및 사용자 정보를 저장하는 핵심 테이블
  - 로그인 ID, 이메일 중복 방지
  - 암호화, 권한, 활성화 여부 등을 모두 포함해야 함
  - 추후 소셜 로그인, 관리자 기능 확장에 대비한 설계 필요

- ## 댓글 (Comment)

  ### 1. 개요

  `comments` 테이블은 게시글에 달리는 사용자 의견을 저장하는 테이블로,
   **게시글(Post)** 과 **사용자(User)** 와의 연관 관계를 포함하며, 다음과 같은 기능을 담당한다.

  - 게시글에 대한 사용자 댓글 저장
  - 대댓글, 시간 순 정렬, 삭제 여부 추적
  - 게시글 삭제 시 댓글 일괄 처리

  ------

  ### 2. 핵심 설계 원칙

  | 항목             | 설계 원칙                                               |
  | ---------------- | ------------------------------------------------------- |
  | 식별자           | `id` (PK) 사용, BIGINT + AUTO_INCREMENT                 |
  | 부모 게시글 참조 | `post_id` (FK → posts.id)                               |
  | 작성자 추적      | `user_id` (FK → users.id)                               |
  | 시간 추적        | `created_at`, `updated_at`                              |
  | 삭제 처리        | `is_deleted` (논리 삭제)                                |
  | 대댓글 지원      | `parent_id` 필드 추가로 계층 구조 형성 가능 (선택 사항) |

  ------

  ### 3. 테이블 정의 (DDL 예시)

  ```
  CREATE TABLE comments (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    post_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    content TEXT NOT NULL,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
  );
  ```

  ------

  ### 4. 필드 설명

  | 필드명       | 타입     | 설명                                |
  | ------------ | -------- | ----------------------------------- |
  | `id`         | BIGINT   | 댓글 고유 ID (PK)                   |
  | `post_id`    | BIGINT   | 해당 댓글이 달린 게시글 ID          |
  | `user_id`    | BIGINT   | 댓글 작성자 ID                      |
  | `content`    | TEXT     | 댓글 내용                           |
  | `is_deleted` | BOOLEAN  | 논리 삭제 여부 (`TRUE`면 표시 안함) |
  | `created_at` | DATETIME | 댓글 생성 시각                      |
  | `updated_at` | DATETIME | 최종 수정 시각                      |

  ------

  ### 5. 인덱스 전략

  | 인덱스 대상  | 목적                            |
  | ------------ | ------------------------------- |
  | `post_id`    | 게시글 기준으로 댓글 목록 조회  |
  | `user_id`    | 사용자 댓글 조회                |
  | `created_at` | 시간순 정렬 (최신순, 오래된 순) |

  예시:

  ```
  CREATE INDEX idx_comments_post_id ON comments(post_id);
  CREATE INDEX idx_comments_user_id ON comments(user_id);
  ```

  ------

  ### 6. 논리 삭제 처리

  물리 삭제 대신 `is_deleted = TRUE` 로 처리한다.
   조회 시 아래와 같은 조건으로 필터링한다:

  ```
  SELECT * FROM comments
  WHERE post_id = ?
    AND is_deleted = FALSE
  ORDER BY created_at ASC;
  ```

  ------

  ### 7. 대댓글(계층형 댓글) 확장 (선택)

  계층형 구조를 원할 경우 `parent_id` 컬럼을 추가해 자기참조 관계를 형성할 수 있다.

  ```
  ALTER TABLE comments ADD COLUMN parent_id BIGINT NULL;
  ALTER TABLE comments ADD FOREIGN KEY (parent_id) REFERENCES comments(id);
  ```

  > 트리 구조 탐색이 필요한 경우 `level`, `group_id`, `depth` 등의 필드 추가 설계 필요.

  ------

  ### 8. 외래 키 관계 요약

  | 관계 대상 | 유형 | 설명                               |
  | --------- | ---- | ---------------------------------- |
  | `posts`   | N:1  | 댓글은 하나의 게시글에 소속됨      |
  | `users`   | N:1  | 댓글은 하나의 사용자에 의해 작성됨 |

  ------

  ### 9. 확장 고려 사항

  | 항목             | 구현 전략                                        |
  | ---------------- | ------------------------------------------------ |
  | 좋아요 기능      | `comment_likes` 테이블 추가                      |
  | 신고 기능        | `comment_reports` 테이블 추가                    |
  | 작성자 닉네임    | 조회 시 JOIN으로 `users.nickname` 참조           |
  | 관리자 삭제 로그 | `deleted_by_admin` BOOLEAN 또는 별도 로그 테이블 |

  ------

  ### 10. 조회 예시 쿼리

  ```
  SELECT c.id, c.content, u.nickname, c.created_at
  FROM comments c
  JOIN users u ON c.user_id = u.id
  WHERE c.post_id = ?
    AND c.is_deleted = FALSE
  ORDER BY c.created_at ASC;
  ```

  ------

  ### 11. 요약

  - 댓글 테이블은 게시글과 사용자에 종속된 하위 도메인 구조
  - 논리 삭제, 시간 정보, 기본 인덱스 구성을 포함해야 함
  - 대댓글 구조는 선택적으로 구현할 수 있음
  - 추후 좋아요, 신고 기능과도 확장 가능

- ## 파일 첨부 (Attachment)

  ### 1. 개요

  `attachments` 테이블은 게시글에 첨부된 **파일의 메타데이터(파일명, 경로, 크기, 업로드 시간 등)** 를 저장하는 용도로 사용된다.
   실제 파일은 DB에 저장하지 않고 **파일 시스템, AWS S3, 클라우드 저장소 등 외부에 저장**하며, DB에는 참조 정보만 기록한다.

  ------

  ### 2. 설계 원칙

  | 항목            | 원칙                                                   |
  | --------------- | ------------------------------------------------------ |
  | 게시글 연동     | `post_id` 외래키로 게시글과 연결                       |
  | 파일 메타데이터 | 원본 파일명, 서버 저장 경로, 파일 크기, MIME 타입 포함 |
  | 다중 첨부 지원  | 게시글 1건당 여러 첨부 가능 (1:N 관계)                 |
  | 파일 중복 방지  | 업로드 시 UUID 또는 해시 기반 이름 적용                |
  | 삭제 정책       | 게시글 삭제 시 파일도 함께 삭제 처리 (물리 또는 논리)  |

  ------

  ### 3. 테이블 정의 (DDL 예시)

  ```
  CREATE TABLE attachments (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    post_id BIGINT NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    stored_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    content_type VARCHAR(100),
    uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id)
  );
  ```

  ------

  ### 4. 필드 설명

  | 필드명          | 타입         | 설명                         |
  | --------------- | ------------ | ---------------------------- |
  | `id`            | BIGINT       | 첨부파일 고유 ID (PK)        |
  | `post_id`       | BIGINT       | 게시글 ID (FK)               |
  | `original_name` | VARCHAR(255) | 업로드 당시 원본 파일명      |
  | `stored_name`   | VARCHAR(255) | 서버에 저장된 이름 (UUID 등) |
  | `file_path`     | VARCHAR(500) | 저장 위치 (상대 경로 or URL) |
  | `file_size`     | BIGINT       | 파일 크기 (byte)             |
  | `content_type`  | VARCHAR(100) | MIME 타입 (예: image/png)    |
  | `uploaded_at`   | DATETIME     | 업로드 시각                  |

  ------

  ### 5. 저장 전략

  | 항목             | 방식                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | 파일 저장 경로   | `/uploads/yyyy/MM/dd/` 등으로 날짜 기반 디렉터리 구분        |
  | 파일명 충돌 방지 | UUID + 원본 확장자 유지 (예: `f41e23a1.png`)                 |
  | 보안             | 저장 경로는 외부에서 직접 접근 불가하게 설정, 접근은 서버 경유 처리 |
  | 삭제 처리        | 파일 삭제는 DB 레코드 삭제와 함께 서버 파일도 삭제해야 함    |

  ------

  ### 6. 인덱스 전략

  | 인덱스 대상   | 목적                           |
  | ------------- | ------------------------------ |
  | `post_id`     | 게시글 기준 첨부파일 목록 조회 |
  | `uploaded_at` | 관리 목적의 시간순 정렬        |

  ```
  CREATE INDEX idx_attachments_post_id ON attachments(post_id);
  ```

  ------

  ### 7. 파일 저장 방식 예시

  ```
  📁 /uploads/2025/06/14/
    ├── 19b2a8c2-4e94-4ab2-a198-f3343dd83afc.pdf  ← stored_name
  ```

  DB에 저장되는 정보:

  | 필드            | 값                                         |
  | --------------- | ------------------------------------------ |
  | `original_name` | "보고서.pdf"                               |
  | `stored_name`   | "19b2a8c2-4e94-4ab2-a198-f3343dd83afc.pdf" |
  | `file_path`     | "/uploads/2025/06/14/"                     |
  | `file_size`     | 1024812                                    |
  | `content_type`  | "application/pdf"                          |

  ------

  ### 8. 파일 다운로드 처리 (Spring 예시)

  ```
  @GetMapping("/attachments/{id}")
  public ResponseEntity<Resource> download(@PathVariable Long id) {
      Attachment attachment = attachmentService.findById(id);
      Resource file = new FileSystemResource(attachment.getFilePath() + attachment.getStoredName());
  
      return ResponseEntity.ok()
          .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + attachment.getOriginalName() + "\"")
          .contentType(MediaType.parseMediaType(attachment.getContentType()))
          .body(file);
  }
  ```

  ------

  ### 9. 확장 고려 사항

  | 항목            | 전략                                          |
  | --------------- | --------------------------------------------- |
  | 썸네일 미리보기 | 별도 썸네일 생성 필드 추가 (`thumbnail_path`) |
  | 파일 권한       | 게시글 비공개 여부에 따라 접근 제한 연동      |
  | 첨부파일 유형   | 이미지/문서/압축 등의 카테고리 분류           |
  | 파일 무결성     | 업로드 시 해시(SHA256 등) 저장 가능           |

  ------

  ### 10. 요약

  - `attachments` 테이블은 게시글에 연결되는 다중 파일 정보를 저장
  - 실파일은 외부 저장소에, 메타정보는 DB에 관리
  - 저장명/경로를 분리하여 보안 및 유연성 확보
  - 업로드/다운로드 처리 시 서버가 직접 파일 경유해야 안전

- ## 좋아요 (Like) 기능

  ### 1. 개요

  `likes` 테이블은 사용자가 게시글에 대해 **"좋아요" 또는 "추천"한 기록**을 저장한다.
   이 테이블은 **중복 추천 방지**, **사용자-게시글 간의 N:M 관계** 표현, 그리고 **좋아요 시간 기록**을 담당한다.

  ------

  ### 2. 설계 원칙

  | 항목             | 원칙                                     |
  | ---------------- | ---------------------------------------- |
  | 중복 추천 방지   | `UNIQUE(post_id, user_id)` 제약조건 설정 |
  | 시간 정보 추적   | `liked_at` 필드로 좋아요 시각 저장       |
  | 성능 고려        | 인덱스를 통한 빠른 조회                  |
  | 연관 무결성 유지 | `post_id`, `user_id`는 모두 외래키 적용  |

  ------

  ### 3. 테이블 정의 (DDL 예시)

  ```
  CREATE TABLE likes (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    post_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    liked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (post_id, user_id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
  );
  ```

  ------

  ### 4. 필드 설명

  | 필드명     | 타입               | 설명                                                   |
  | ---------- | ------------------ | ------------------------------------------------------ |
  | `id`       | BIGINT             | 기본키                                                 |
  | `post_id`  | BIGINT             | 좋아요가 눌린 게시글 ID                                |
  | `user_id`  | BIGINT             | 좋아요를 누른 사용자 ID                                |
  | `liked_at` | DATETIME           | 좋아요한 시각                                          |
  | `UNIQUE`   | (post_id, user_id) | 동일 사용자가 동일 게시글에 여러 번 추천하지 못하게 함 |

  ------

  ### 5. 인덱스 전략

  | 인덱스 대상                 | 목적                       |
  | --------------------------- | -------------------------- |
  | `post_id`                   | 게시글 기준 좋아요 수 계산 |
  | `user_id`                   | 사용자별 추천 이력 조회    |
  | `post_id, user_id` (Unique) | 중복 방지 및 빠른 조회     |

  ```
  CREATE INDEX idx_likes_post_id ON likes(post_id);
  CREATE INDEX idx_likes_user_id ON likes(user_id);
  ```

  ------

  ### 6. 좋아요 수 계산 예시

  ```
  SELECT COUNT(*) AS like_count
  FROM likes
  WHERE post_id = ?;
  ```

  게시글 리스트 조회 시 서브쿼리 또는 별도 테이블에 집계해놓는 전략도 사용 가능 (성능 최적화 목적).

  ------

  ### 7. 관계 요약

  | 관계 대상 | 관계 유형 | 설명                                  |
  | --------- | --------- | ------------------------------------- |
  | `posts`   | N:1       | 여러 좋아요는 하나의 게시글에 속함    |
  | `users`   | N:1       | 한 사용자는 여러 게시글에 좋아요 가능 |

  총체적으로는 사용자와 게시글 간 **N:M 관계**를 나타낸다.

  ------

  ### 8. Spring MVC / JPA 연동 예시

  - 좋아요 추가

  ```
  likeRepository.save(new Like(postId, userId));
  ```

  - 좋아요 취소

  ```
  likeRepository.deleteByPostIdAndUserId(postId, userId);
  ```

  - 좋아요 유무 체크

  ```
  Optional<Like> result = likeRepository.findByPostIdAndUserId(postId, userId);
  ```

  ------

  ### 9. 확장 고려 사항

  | 항목                | 구현 방식                                                    |
  | ------------------- | ------------------------------------------------------------ |
  | 싫어요 기능         | `dislikes` 테이블 추가 또는 `likes` 테이블에 `type` 필드 (`LIKE`, `DISLIKE`) 추가 |
  | 좋아요 알림 기능    | 좋아요 발생 시 `notifications` 테이블에 기록                 |
  | 게시글 외 대상 확장 | 댓글 좋아요 등을 지원할 경우 `target_type`, `target_id` 컬럼 추가 |
  | 취소 허용 여부 설정 | `deleted_at` 필드 또는 soft-delete 적용                      |

  ------

  ### 10. 조회 예시 쿼리

  - 게시글 좋아요 목록

  ```
  SELECT u.username, l.liked_at
  FROM likes l
  JOIN users u ON l.user_id = u.id
  WHERE l.post_id = ?
  ORDER BY l.liked_at DESC;
  ```

  - 사용자가 좋아요한 게시글 목록

  ```
  SELECT p.id, p.title
  FROM likes l
  JOIN posts p ON l.post_id = p.id
  WHERE l.user_id = ?;
  ```

  ------

  ### 11. 요약

  - `likes` 테이블은 사용자와 게시글 간 좋아요 이력을 저장하며, 중복을 방지해야 한다
  - 시간 정보 저장과 빠른 조회를 위한 인덱스가 중요
  - 싫어요, 알림, 댓글 추천 기능 등으로 확장 가능
  - 성능 최적화를 위해 캐싱 또는 비정규화된 count 필드 활용 고려

## DDL 작성 및 테이블 생성

### 1. 사용자 테이블 (`users`)

```
CREATE TABLE users (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  username VARCHAR(50) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  email VARCHAR(100) NOT NULL UNIQUE,
  nickname VARCHAR(50),
  role VARCHAR(20) DEFAULT 'USER',
  is_active BOOLEAN DEFAULT TRUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

------

### 2. 게시글 테이블 (`posts`)

```
CREATE TABLE posts (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  title VARCHAR(200) NOT NULL,
  content TEXT NOT NULL,
  view_count INT DEFAULT 0,
  is_deleted BOOLEAN DEFAULT FALSE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 3. 댓글 테이블 (`comments`)

```
CREATE TABLE comments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  content TEXT NOT NULL,
  is_deleted BOOLEAN DEFAULT FALSE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 4. 첨부파일 테이블 (`attachments`)

```
CREATE TABLE attachments (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  original_name VARCHAR(255) NOT NULL,
  stored_name VARCHAR(255) NOT NULL,
  file_path VARCHAR(500) NOT NULL,
  file_size BIGINT NOT NULL,
  content_type VARCHAR(100),
  uploaded_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id)
);
```

------

### 5. 좋아요 테이블 (`likes`)

```
CREATE TABLE likes (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  post_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  liked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (post_id, user_id),
  FOREIGN KEY (post_id) REFERENCES posts(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

------

### 6. 인덱스 정의 (선택적으로 명시적 생성)

```
-- 게시글
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_created_at ON posts(created_at);

-- 댓글
CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);

-- 첨부파일
CREATE INDEX idx_attachments_post_id ON attachments(post_id);

-- 좋아요
CREATE INDEX idx_likes_post_id ON likes(post_id);
CREATE INDEX idx_likes_user_id ON likes(user_id);
```

------

### 7. 제약조건 요약

| 제약 조건 | 설명                                                       |
| --------- | ---------------------------------------------------------- |
| PK        | 각 테이블의 `id` (AUTO_INCREMENT)                          |
| FK        | `posts.user_id → users.id`                                 |
| FK        | `comments.user_id → users.id`                              |
| FK        | `comments.post_id → posts.id`                              |
| FK        | `attachments.post_id → posts.id`                           |
| FK        | `likes.user_id → users.id`                                 |
| FK        | `likes.post_id → posts.id`                                 |
| UNIQUE    | `users.username`, `users.email`, `likes(post_id, user_id)` |

------

### 8. 생성 순서 주의

> 외래키 제약 때문에 반드시 다음 순서대로 생성해야 오류가 없다:

1. `users`
2. `posts`
3. `comments`
4. `attachments`
5. `likes`

## Index / Foreign Key 구성 전략

### 1. Index 설계 전략

인덱스는 다음과 같은 기준으로 설계한다:

| 기준                         | 설명                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 자주 검색되는 컬럼           | `WHERE`, `ORDER BY`, `JOIN`에 사용되는 컬럼에 인덱스 적용    |
| 중복이 낮은 컬럼 우선        | 인덱스는 유니크한 값일수록 효율적                            |
| 복합 인덱스는 순서 고려      | `WHERE col1 = ? AND col2 = ?`인 경우 `(col1, col2)`가 유리   |
| 쓰기 성능 고려               | 인덱스가 많을수록 `INSERT`, `UPDATE`는 느려짐                |
| 조건 필터링 + 정렬 동시 사용 | `WHERE` + `ORDER BY`를 동시에 처리할 수 있는 인덱스는 별도 생성 필요 |

------

#### 📌 추천 인덱스 구성

| 테이블        | 인덱스 컬럼                        | 목적                             |
| ------------- | ---------------------------------- | -------------------------------- |
| `users`       | `username`, `email` (UNIQUE)       | 로그인, 사용자 검색              |
| `posts`       | `user_id`, `created_at`            | 유저별 게시글, 최신순 정렬       |
| `comments`    | `post_id`, `user_id`, `created_at` | 게시글당 댓글 조회               |
| `attachments` | `post_id`                          | 게시글-첨부파일 매핑             |
| `likes`       | `post_id`, `user_id` (UNIQUE)      | 중복 추천 방지 및 좋아요 수 조회 |

```
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_created_at ON posts(created_at);

CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);

CREATE INDEX idx_likes_post_id ON likes(post_id);
CREATE INDEX idx_likes_user_id ON likes(user_id);
```

------

### 2. Foreign Key 설계 전략

외래 키는 다음과 같은 원칙으로 설계한다:

| 원칙                    | 설명                                             |
| ----------------------- | ------------------------------------------------ |
| 데이터 무결성 확보      | 삭제/수정 시 부모 레코드가 존재해야 함           |
| 참조 무결성 옵션 명확화 | `ON DELETE CASCADE` / `SET NULL` / `RESTRICT` 등 |
| 성능 이슈 고려          | 대량 삽입 시 외래 키 제약은 비용이 발생함        |
| 삭제 정책 일관성 유지   | 게시글 삭제 시 댓글/첨부파일 자동 삭제 여부 결정 |

------

#### 📌 외래 키 구성

| 자식 테이블   | 부모 테이블 | 외래 키 컬럼 | 제약 옵션                           |
| ------------- | ----------- | ------------ | ----------------------------------- |
| `posts`       | `users`     | `user_id`    | `ON DELETE CASCADE` 추천            |
| `comments`    | `users`     | `user_id`    | `ON DELETE SET NULL` 또는 `CASCADE` |
| `comments`    | `posts`     | `post_id`    | `CASCADE` 또는 `RESTRICT`           |
| `attachments` | `posts`     | `post_id`    | `CASCADE`                           |
| `likes`       | `users`     | `user_id`    | `CASCADE`                           |
| `likes`       | `posts`     | `post_id`    | `CASCADE`                           |

```
-- 예시: 게시글 삭제 시 댓글도 함께 삭제
FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE;
```

------

### 3. 삭제 정책에 따른 외래 키 옵션 정리

| 상황                           | 추천 외래 키 옵션                    |
| ------------------------------ | ------------------------------------ |
| 게시글 삭제 시 댓글도 삭제     | `ON DELETE CASCADE`                  |
| 사용자 삭제 시 게시글 남김     | `ON DELETE SET NULL` (Nullable 필요) |
| 좋아요/첨부파일 자동 삭제 필요 | `ON DELETE CASCADE`                  |
| 논리 삭제 사용하는 경우        | `ON DELETE RESTRICT` + soft delete   |

------

### 4. 성능 및 안정성에 대한 고려

| 항목              | 전략                                                         |
| ----------------- | ------------------------------------------------------------ |
| 대량 데이터 삽입  | 외래 키 일시 해제 후 삽입 가능 (`SET foreign_key_checks = 0`) |
| 조인 최적화       | 조인 조건 컬럼에 반드시 인덱스 존재해야 함                   |
| 정기 분석         | `ANALYZE TABLE`로 통계 최신화                                |
| 외래 키 순서 주의 | 부모 → 자식 순서로 테이블 생성, 삭제는 반대                  |

------

### 5. ERD 기준 핵심 관계도 요약

```
users ─────┐
           │
           ├───< posts ─────┐
           │                │
           └───< comments >─┘
                     │
     attachments <───┘
                     │
     likes      <────┘
```

------

### 6. 요약

- **인덱스는 조회 조건과 정렬 순서 기반으로 최소한만 생성**
- **외래 키는 무결성 보장과 삭제 연쇄 처리를 위한 핵심 도구**
- **ON DELETE CASCADE와 SET NULL을 전략적으로 조합**
- **논리 삭제 시에는 외래 키와 물리 삭제 옵션이 충돌하지 않게 주의**

## 트랜잭션 전략 설계

### 1. 트랜잭션이란?

트랜잭션은 **하나의 논리적 작업 단위**를 의미하며, 아래의 ACID 속성을 만족해야 한다:

| 속성        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| Atomicity   | 원자성. 전부 수행되거나 전혀 수행되지 않아야 한다            |
| Consistency | 일관성. 작업 전후 상태가 무결해야 한다                       |
| Isolation   | 독립성. 동시에 수행 중인 트랜잭션은 서로 간섭하지 않아야 한다 |
| Durability  | 지속성. 성공한 트랜잭션 결과는 영구히 반영되어야 한다        |

------

### 2. 트랜잭션 기본 단위 정의

기능 단위로 트랜잭션 범위를 정의한다:

| 기능        | 트랜잭션 단위                                      |
| ----------- | -------------------------------------------------- |
| 게시글 등록 | 게시글 + 첨부파일 + 알림 전부 포함                 |
| 댓글 작성   | 댓글 + 알림                                        |
| 회원 가입   | 사용자 + 초기 세팅 정보                            |
| 좋아요 처리 | 단일 처리지만 중복 방지 및 예외 시 롤백 필요       |
| 게시글 삭제 | 게시글 + 댓글 + 첨부파일 연쇄 삭제 → 트랜잭션 필요 |
| 로그인      | DB 트랜잭션 필요 없음 (세션/토큰 처리 중심)        |

------

### 3. 선언적 트랜잭션 처리 (`@Transactional`)

Spring에서는 선언적 트랜잭션을 기본으로 사용하며, 서비스 계층에 설정한다:

```
@Service
public class PostService {
  
  @Transactional
  public void createPost(Post post, List<MultipartFile> files) {
      postRepository.save(post);
      attachmentService.saveFiles(post, files);  // 실패 시 전체 롤백
  }

  @Transactional
  public void deletePost(Long postId) {
      commentRepository.deleteByPostId(postId);
      attachmentRepository.deleteByPostId(postId);
      postRepository.deleteById(postId);
  }
}
```

------

### 4. 트랜잭션 전파 옵션

| 전파 옵션           | 설명                                                  |
| ------------------- | ----------------------------------------------------- |
| `REQUIRED` (기본값) | 현재 트랜잭션 있으면 참여, 없으면 새로 생성           |
| `REQUIRES_NEW`      | 항상 새로운 트랜잭션 시작 (기존 트랜잭션은 일시 정지) |
| `NESTED`            | 내부 트랜잭션. 롤백은 내부만 적용 가능                |
| `SUPPORTS`          | 트랜잭션이 있으면 참여, 없어도 실행                   |
| `NOT_SUPPORTED`     | 트랜잭션 없이 실행                                    |

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void sendNotification(...) {
    ...
}
```

> 예: 게시글은 실패해도 알림은 전송해야 한다 → 알림은 `REQUIRES_NEW`

------

### 5. 트랜잭션 격리 수준

MariaDB의 기본 격리 수준은 `REPEATABLE READ`이다. 일반적인 상황에 적합하지만, 동시성 문제가 발생할 수 있다.

| 수준               | 설명                            | 허용되는 현상            |
| ------------------ | ------------------------------- | ------------------------ |
| `READ UNCOMMITTED` | 커밋 전 데이터도 읽음           | Dirty Read 가능          |
| `READ COMMITTED`   | 커밋된 데이터만 읽음            | Non-repeatable Read 허용 |
| `REPEATABLE READ`  | 동일 트랜잭션 내 같은 결과 보장 | Phantom Read 허용        |
| `SERIALIZABLE`     | 가장 엄격한. 동시성 낮음        | 없음 (성능 저하 큼)      |

```
@Transactional(isolation = Isolation.READ_COMMITTED)
```

------

### 6. 예외 처리 전략

트랜잭션 롤백은 기본적으로 **런타임 예외 (`RuntimeException`)** 발생 시 동작한다.
 체크 예외 (`Exception`) 에 대해서는 명시적으로 설정해야 한다.

```
@Transactional(rollbackFor = Exception.class)
```

| 상황                  | 처리 전략                                |
| --------------------- | ---------------------------------------- |
| DB 관련 런타임 예외   | 자동 롤백됨 (`DataAccessException`)      |
| 사용자 정의 체크 예외 | 명시적으로 `rollbackFor` 설정 필요       |
| 외부 API 실패         | `REQUIRES_NEW`로 격리하여 롤백 분리 가능 |

------

### 7. 트랜잭션 분할 전략 (단일 책임 원칙)

하나의 서비스 메서드에서 여러 외부 시스템이나 도메인을 조작할 경우
 트랜잭션을 **작은 단위로 분할**하는 것이 좋다:

```
@Transactional
public void updatePostAndNotify(...) {
    postService.update(...);                // Rollback 대상
    notificationService.send(...);         // 실패해도 Rollback 안 함 (REQUIRES_NEW)
}
```

------

### 8. 동시성 제어

동시 추천 처리, 중복 댓글 삽입 방지 등의 **경합 상황**에서는 추가적인 제어가 필요하다:

| 전략                         | 설명                                                     |
| ---------------------------- | -------------------------------------------------------- |
| 낙관적 락 (Optimistic Lock)  | 버전 필드를 기반으로 충돌 감지                           |
| 비관적 락 (Pessimistic Lock) | 조회 시점에서 `FOR UPDATE` 등으로 잠금                   |
| 유니크 제약조건 활용         | 추천 등은 `UNIQUE` + 예외 기반 제어가 더 단순하고 효율적 |

------

### 9. 트랜잭션과 JPA 주의사항

| 항목                                  | 설명                                    |
| ------------------------------------- | --------------------------------------- |
| 트랜잭션 안에서 Lazy 로딩 보장됨      | 밖에서는 `LazyInitializationException`  |
| `flush()` 시점에 쿼리 실행됨          | 영속성 컨텍스트에 따라 실쿼리 지연 가능 |
| Entity 수정은 트랜잭션 커밋 시 반영됨 | `@Transactional` 필수                   |

------

### 10. 요약

- 서비스 단위별 `@Transactional` 전략이 기본
- 알림, 외부 API 등은 `REQUIRES_NEW`로 분리 처리
- DB 동시성 이슈는 유니크 제약이나 락으로 보완
- 예외는 명확하게 구분하여 롤백 조건 지정
- 트랜잭션 범위는 **짧고 명확하게 유지**해야 성능과 안정성이 보장됨